# C++ポインタ早見表

## 基本概念

| 概念 | 説明 | 例 |
|------|------|-----|
| ポインタ | メモリアドレスを格納する変数 | `int* ptr;` |
| アドレス演算子 `&` | 変数のメモリアドレスを取得する | `&x` はxのアドレス |
| デリファレンス演算子 `*` | ポインタが指す値を取得/設定する | `*ptr = 10;` |
| `nullptr` (C++11) | ポインタが何も指していないことを示す値 | `int* ptr = nullptr;` |

## ポインタの宣言と初期化

| 操作 | 構文 | 説明 |
|------|------|-----|
| 宣言 | `Type* pointerName;` | 特定の型を指すポインタの宣言 |
| 初期化 (変数のアドレス) | `Type* ptr = &variable;` | 既存の変数のアドレスでポインタを初期化 |
| 初期化 (nullptr) | `Type* ptr = nullptr;` | 何も指さないポインタで初期化 (C++11) |
| 初期化 (動的メモリ) | `Type* ptr = new Type;` | 動的に割り当てられたメモリでポインタを初期化 |

## ポインタの操作

| 操作 | 例 | 説明 |
|------|------|-----|
| デリファレンス | `*ptr` | ポインタが指す値にアクセス |
| 値の変更 | `*ptr = value;` | ポインタが指すメモリの値を変更 |
| ポインタの再代入 | `ptr = &anotherVar;` | ポインタに別の変数のアドレスを代入 |
| ポインタの演算 | `ptr + n` | 指定した型サイズ × nだけアドレスを進める |
| ポインタのインクリメント | `ptr++` | 次の要素を指すようポインタを進める |
| ポインタのデクリメント | `ptr--` | 前の要素を指すようポインタを戻す |
| ポインタの比較 | `ptr1 == ptr2` | 2つのポインタが同じアドレスを指しているか比較 |

## ポインタと配列

| 概念 | 例 | 説明 |
|------|------|-----|
| 配列名 | `array` | 配列の先頭要素のアドレス |
| 配列要素へのアクセス | `array[i]` または `*(array + i)` | 配列のi番目の要素にアクセス |
| 配列のポインタ操作 | `int* ptr = array;` | 配列の先頭を指すポインタ |
| ポインタによる配列走査 | `for (int* p = array; p < array + size; p++)` | ポインタを使って配列を走査 |

## 関数とポインタ

| 概念 | 例 | 説明 |
|------|------|-----|
| ポインタによる参照渡し | `void func(int* ptr) { (*ptr)++; }` | 関数内で呼び出し元の変数を変更可能 |
| 配列の引数 | `void func(int arr[], int size)` | 配列は常にポインタとして渡される |
| const ポインタ引数 | `void func(const int* ptr)` | 値を読み取れるが変更はできない |
| 関数ポインタ | `returnType (*funcPtr)(paramTypes)` | 関数を指すポインタ |

## 動的メモリ管理

| 操作 | 構文 | 説明 |
|------|------|-----|
| 単一要素の確保 | `Type* ptr = new Type;` | 1つの要素分のメモリを確保 |
| 初期化付き確保 | `Type* ptr = new Type(value);` | 値を指定して確保 |
| 配列の確保 | `Type* ptr = new Type[size];` | 配列分のメモリを確保 |
| 単一要素の解放 | `delete ptr;` | 動的に確保したメモリを解放 |
| 配列の解放 | `delete[] ptr;` | 動的に確保した配列を解放 |

## スマートポインタ (C++11以降)

| 種類 | 例 | 説明 |
|------|------|-----|
| `std::unique_ptr` | `std::unique_ptr<int> ptr = std::make_unique<int>(10);` | 排他的所有権を持つスマートポインタ (C++14) |
| `std::shared_ptr` | `std::shared_ptr<int> ptr = std::make_shared<int>(10);` | 共有所有権を持つ参照カウント式ポインタ |
| `std::weak_ptr` | `std::weak_ptr<int> wptr = sharedPtr;` | 循環参照を防ぐための弱参照ポインタ |

## よくあるポインタのエラーと対策

| エラー | 例 | 対策 |
|------|------|-----|
| 未初期化ポインタ | `int* ptr; *ptr = 10;` | 必ず初期化する: `int* ptr = nullptr;` |
| メモリリーク | `int* ptr = new int; /* delete忘れ */` | `delete`を忘れない、スマートポインタを使用 |
| ダブルフリー | `delete ptr; delete ptr;` | 解放後は`nullptr`を代入: `ptr = nullptr;` |
| ダングリングポインタ | `int* p = &x; /* xがスコープから出た後 */` | 有効性を確認、スマートポインタの使用 |
| 配列と単一要素の混同 | `int* arr = new int[10]; delete arr;` | 配列なら`delete[]`を使用 |

## ポインタ使用時の基本ルール

1. **必ず初期化する**: 未初期化ポインタを使わない
2. **使用前に確認する**: `nullptr`チェックを行う
3. **所有権を明確にする**: 誰がメモリを解放する責任を持つか明確にする
4. **可能な限りスマートポインタを使う**: 手動メモリ管理のエラーを減らす
5. **関数間で受け渡す場合は慎重に**: 生存期間と所有権に注意する