// 問題1: 最大部分和問題
// 問題文
// 整数の配列が与えられたとき、連続する部分配列の要素の和の最大値を求めなさい。
// 例えば、配列 [-2, 1, -3, 4, -1, 2, 1, -5, 4] が与えられた場合、連続する部分配列 [4, -1, 2, 1] の和が6で最大となります。


#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int maxSubArray(vector<int>& nums) {
  // DPテーブル: dp[i]は配列のi番目までの最大部分和
  int n = nums.size();
  int dp = nums[0];      // 現在までの最大部分和
  int result = nums[0];  // 全体の最大部分和

  for (int i = 1; i < n; i++) {
    // 各ステップで「新しく始めるか」「続けるか」の選択を行い、その時点で最も利益の大きい選択をしています。この選択を繰り返すことで、最終的に最大の部分和を持つ部分配列を見つけることができます。
    dp = max(nums[i], dp + nums[i]);
    result = max(result, dp);
  }

  return result;
}

int main() {
  vector<int> nums = {-2, 1, -3, 4, -1, 2, 1, -5, 4};
  cout << "最大部分和: " << maxSubArray(nums) << endl; // => 最大部分和: 6

  return 0;
}

// このアルゴリズムは以下のステップで動作します：

// 1. 初期化:
// - dp変数を配列の最初の要素で初期化します。これは「現在位置までの最大部分和」を表します。
// - result変数も同様に最初の要素で初期化します。これは「見つかった最大部分和」を記録します。


// 2. イテレーション:
// - 配列の2番目の要素から順に処理します。
// - 各要素iについて、次の選択をします：
//   - その要素から新しい部分配列を始める（nums[i]）
//   - または、前の部分和に現在の要素を追加する（dp + nums[i]）
// - これらの選択肢のうち大きい方を新しいdp値とします。
// - もし新しいdpが現在のresultより大きければ、resultを更新します。

// 3. 結果:
// - 全ての要素を処理した後、resultが最大部分和となります。


// 具体例での動作
// 例として配列 [-2, 1, -3, 4, -1, 2, 1, -5, 4] でのアルゴリズムの動きを追跡します：

// 1. 初期化: dp = -2, result = -2

// 2. i = 1 (値は1):
//   - dp = max(1, -2+1) = max(1, -1) = 1
//   - result = max(-2, 1) = 1

// 3. i = 2 (値は-3):
//   - dp = max(-3, 1+(-3)) = max(-3, -2) = -2
//   - result = max(1, -2) = 1

// 4. i = 3 (値は4):
//   - dp = max(4, -2+4) = max(4, 2) = 4
//   - result = max(1, 4) = 4

// 5. i = 4 (値は-1):
//   - dp = max(-1, 4+(-1)) = max(-1, 3) = 3
//   - result = max(4, 3) = 4

// 6. i = 5 (値は2):
//   - dp = max(2, 3+2) = max(2, 5) = 5
//   - result = max(4, 5) = 5

// 7. i = 6 (値は1):
//   - dp = max(1, 5+1) = max(1, 6) = 6
//   - result = max(5, 6) = 6

// 8. i = 7 (値は-5):
//   - dp = max(-5, 6+(-5)) = max(-5, 1) = 1
//   - result = max(6, 1) = 6

// 9. i = 8 (値は4):
//   - dp = max(4, 1+4) = max(4, 5) = 5
//   - result = max(6, 5) = 6

// 最終的な最大部分和は6となり、これは部分配列[4, -1, 2, 1]の和に対応します。